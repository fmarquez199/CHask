@Inventory Inv: @ Tamaño 13
@  Power a = 0
@  Skill b = 2'4
@  Battle c
@.~
@Items It: @ Tamaño 8
@  Power a
@  Skill b
@  Battle c
@.~
@boss b(Power num):
@  drop num
@.~
@monster m(Skill s) Skill:
@  unlock s + 1'5
@.~
@monster m(Runes str) Runes:
@  unlock str
@.~

world %Pruebas%:

  @Power x = 2
  @Power y = 3
  @Skill f = 1'0


@ Operaciones aritmeticas
  @Power i0 = x + 1
  @Power i1 = x - 1
  @Power i2 = x * 1
  @Power i4 = x % 1
  @Power i5 = x // 1
  @Skill f0 = f + 2'5
  @Skill f1 = f * f
  @Skill f2 = f / 0'5
  @Skill f3 = f / f
  @Skill f4 = x / y

@ Operaciones unarias
  @Power  y = -5
  @Power  y' = -y
  @Skill   f = -5'2
  @Skill   f' = -f
@Rune   c = *4*
@Rune  up = ^*x*
@Rune low = .*x*

@ Operaciones boleanas
  Battle b @= Lose
  @b = !Win
  @b = Lose || Win
@  b = Win && Lose
@b = Lose || b
@b = Lose && b
@b = Win && 3 > 6
@Battle p = 3 > 6
@p = i5 < i2

@ Operador ternario
  @Battle b
  @Battle b1 = Win ? (3 == 6) : (3 > 6)
  @Skill f1 = Lose ? 6'0 : 3'0
@Battle b2 = b ? (3 == 6) : (3 > 6)
Skill f0 = 6'5
Skill f1 = 3'4
Skill f2 = b ? f0 : f1
drop f2

@  play:
  @  gameOver
  @  Power i = 9
  @  keepPlaying
  @  x++
  @lock (x < 10)
  @.~

@  controller x = 0 -> 10: @ lock i % 2 == 0:
  @  gameOver
  @  keepPlaying
  @  Button:
  @    | x == 7 }
  @      i0 = x * i1
  @      gameOver
  @  .~
  @  i2 = i0 * i1
  @.~

  @Power i

  @controller i = 1 -> 5:
  @  drop i
  @.~
  
  @Power x, n = 1
  @controller x = 1 -> 10 lock x < 5: @ lock i % 2 == 0:
  @  n = n * x
  @  drop n
  @.~

@  Button:
  @  | Lose       } x = 0
  @  | x > 3      } x = 10
  @  | x == 20    } x = 1
  @  | Lose       } x = 0
  @  | Win        } x = 30 @ AST no se genera bien. La x en el default tiene el mismo valor que aquí
  @  | notPressed } x = 720
  @.~

@ Subrutinas
  @Power x = 10
  @Skill y = 10'4
  @kill b(x)
  @x = kill m(x)
  @y = kill m(y)
  @Power|}x{| arr0     @ Esto esta dando error cuando se inicializa por defecto un arreglo
  @Power|}5{| arr1
  @x = kill m(arr1)

@ Arreglos
  @Power|}3{| array = |)2, 3, 4(|
  @Power len = #array
  @array|)0(| = 0
  @x = array|)0(|

  @controller Power e <- |)2, 3(|:
  @  Power i = e
  @.~

@ Apuntadores
  @Power puff apt1 = summon Power
  @Rune|}3{| puff apt2
  @puff apt1 = 50
  @puff apt2 = |)*a*, *b*, *4*(|
  @kill b(apt1,10'6)
  @free apt1
  @free apt2

@ I/O
  @Runes s = ~3g~
  @Runes j = joystick ~Here we go~
  @drop s
  @drop ~hola mundo!!~

@ Strings
  @Rune|}4{| x = |)*H*, *o*, *l*, *a*(|
  @Runes y = ~H~
  @Runes x = y
  @Runes y = ~Hola, soy un string~
  @Runes s = kill m(y) @ not implemented
  @drop y
  @drop ~Este es otro string~


"'Ejemplos por implementar en TAC, arriba estan cosas probadas que funcionan'"
@ Listas
  @Kit of Power list = <<10, 21, 3>> :: (<<2>> :: <<0>>) @ This is a problem
  @Kit of Power list1 = <<4,2>>
  @Kit of Power empty = << >>
  @list1|>0<| = 10

@ Registros
  @Inv inv = Inv {10 , 1'8, Lose}
  @Power elem = inv spawn a
  @kill b( inv , 1'0)

.~
