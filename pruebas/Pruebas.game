@Inventory Inv: @ Tamaño 13
@  Power a = 0
@  Skill b = 2'4
@  Battle c
@.~
@Items It: @ Tamaño 8
@  Power a
@  Skill b
@  Battle c
@.~
@boss b(Power num):
@  drop num
@.~
@monster m(Skill s) Skill:
@  unlock s + 1'5
@.~
@monster m(Runes str) Runes:
@  unlock str
@.~

world %Pruebas%:

  @Power x = 1
  @Power y = 3
  @Skill f = 5'4

@ Operaciones aritmeticas
  @Power i0
  @i0 = x + y
  @drop i0
  @Skill f1 = f * f
  @Skill f3 = f / f
  @Skill f4 = x / y
  Power i0 = 5, i1 = 2
  Skill f0
  f0 = i0 / i1
  drop f0
@Power i1 = x - 1
@Power i2 = x * 1
@Power i4 = x % 1
@Power i5 = x // 1
@Skill f0 = f + 2'5
@Skill f2 = f / 0'5

@ Operaciones unarias
  @Power  y2
  @y2 = -y
  @drop y2
  @Skill  f2
  @f2 = -f
  @drop f2
@Skill   f = -5'2
@Skill   f' = -f
@Power  y1 = -5
@Power  y2 = -y
@Rune   c = *4*
@Rune  up = ^*x*
@Rune low = .*x*

@ Operaciones boleanas
  @Battle b @= Lose
  @b = !Win
  @b = Lose || Win
  @b = Win && Lose
  @b = Lose || b
  @b = Lose && b
  @b = i5 < i2
@b = Win && 3 > 6
@b = 3 > 6

@ Operador ternario
  @Battle b
  @Battle b1 = Win ? (3 == 6) : (3 > 6)
  @Skill f1 = Lose ? 6'0 : 3'0
@Battle b2 = b ? (3 == 6) : (3 > 6)
@Skill f0 = 6'5
@Skill f1 = 3'4
@Skill f2 = b ? f0 : f1
@drop f2

@  play:
  @  gameOver
  @   i0 = 9   @ No se esta cambiando el valor, esta bien??
  @  keepPlaying  @ deberia saler del ciclo
  @  Button:
  @    | x == 7 }
  @      x = x * y
  @      gameOver
  @    | x == 4 } keepPlaying  @ deberia saltarse x=4 y seguir imprimiendo x
  @  .~
  @  drop x  @ el primer drop lo hace mal, x=1 pero muestra 0
  @  x++
  @lock (x < 10)
  @.~
  @drop x
@
  @Power i
@  controller i = 1 -> 10: @ lock i % 2 == 0:
  @  gameOver
  @  keepPlaying
  @  Button:
  @    | i == 7 }
  @      x = i * y
  @      gameOver
  @    | i == 4 } keepPlaying
  @  .~
  @  drop i
  @  x = i
  @.~
  @drop i
  @drop x

@  Button:
  @  | x < 3      } x = 10
  @  | x == 1    } x = 12
  @  | Lose       } x = 0
  @  | Win        } x = 30
  @  | notPressed } x = 720
  @.~
  @drop x

@ I/O
  @Power geti = joystick ~Un Entero~
  @drop geti
@Skill getf = joystick ~Un flotante~
@drop getf
  @Runes gets = joystick ~Un String~
  @drop gets
@Runes getc = joystick ~Un Char~
@drop getc
@Runes getnull = joystick
@drop getnull

@ Strings
  @Rune|}4{| x = |)*H*, *o*, *l*, *a*(|
  @Runes y = ~Hola, soy un string~
  @Runes x = y
  @drop y
  @drop ~Este es otro string~
@Runes s = kill m(y) @ not implemented

@ Subrutinas
  @Power x = 10
  @Skill y = 10'4
  @kill b(x)
  @x = kill m(x)
  @y = kill m(y)
  @Power|}x{| arr0    @ Err cuando init por defecto un arreglo
  @Power|}5{| arr1
  @x = kill m(arr1)

@ Arreglos
  @Power|}3{| array = |)2, 3, 4(|
  @Power len = #array
  @array|)0(| = 0
  @x = array|)0(|

  @controller Power e <- |)2, 3(|:
  @  Power i = e
  @.~

@ Apuntadores
  @Power puff apt1 = summon Power
  @Rune|}3{| puff apt2
  @puff apt1 = 50
  @puff apt2 = |)*a*, *b*, *4*(|
  @kill b(apt1,10'6)
  @free apt1
  @free apt2


"'Ejemplos por implementar en TAC, arriba estan cosas probadas que funcionan'"
@ Listas
  @Kit of Power list = <<10, 21, 3>> :: (<<2>> :: <<0>>) @ This is a problem
  @Kit of Power list1 = <<4,2>>
  @Kit of Power empty = << >>
  @list1|>0<| = 10

@ Registros
  @Inv inv = Inv {10 , 1'8, Lose}
  @Power elem = inv spawn a
  @kill b( inv , 1'0)

.~
